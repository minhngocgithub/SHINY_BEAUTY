# CATEGORY HIERARCHY IMPLEMENTATION GUIDE

## 📋 OVERVIEW
Transform flat category structure to hierarchical (parent-child) system while preserving existing data.

---

## 🗄️ 1. DATABASE SCHEMA CHANGES

### 1.1 Enhanced Category Model
**File:** `models/category.models.js`

**NEW FIELDS TO ADD:**
```javascript
{
  // Existing fields (keep as is):
  name: String,
  createdAt: Date,
  updatedAt: Date,
  __v: Number,
  
  // NEW FIELDS:
  slug: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  
  parent: {
    type: mongoose.Schema.ObjectId,
    ref: 'Category',
    default: null,
    index: true
  },
  
  level: {
    type: Number,
    default: 0,
    min: 0,
    max: 3
  },
  
  path: {
    type: String,
    index: true
  },
  
  displayOrder: {
    type: Number,
    default: 0
  },
  
  isActive: {
    type: Boolean,
    default: true
  },
  
  showInMenu: {
    type: Boolean,
    default: true
  },
  
  icon: String,
  
  image: {
    public_id: String,
    url: String
  },
  
  description: String,
  
  productCount: {
    type: Number,
    default: 0
  }
}
```

**VIRTUALS:**
```javascript
categorySchema.virtual('children', {
  ref: 'Category',
  localField: '_id',
  foreignField: 'parent'
});
```

**INDEXES:**
```javascript
categorySchema.index({ parent: 1, displayOrder: 1 });
categorySchema.index({ slug: 1 }, { unique: true });
categorySchema.index({ path: 1 });
categorySchema.index({ level: 1 });
categorySchema.index({ isActive: 1, showInMenu: 1 });
```

**PRE-SAVE MIDDLEWARE:**
```javascript
categorySchema.pre('save', async function(next) {
  // Auto-generate slug
  if (this.isModified('name') && !this.slug) {
    const slugify = require('slugify');
    this.slug = slugify(this.name, { lower: true, strict: true });
  }
  
  // Calculate level & path
  if (this.parent) {
    const parent = await this.constructor.findById(this.parent);
    if (parent) {
      this.level = parent.level + 1;
      this.path = parent.path ? `${parent.path}/${this._id}` : `${parent._id}/${this._id}`;
    }
  } else {
    this.level = 0;
    this.path = this._id.toString();
  }
  
  next();
});
```

**INSTANCE METHODS:**
```javascript
// Get all ancestors
categorySchema.methods.getAncestors = async function() {
  if (!this.parent) return [];
  
  const ancestors = [];
  let current = await this.constructor.findById(this.parent);
  
  while (current) {
    ancestors.unshift(current);
    current = current.parent ? await this.constructor.findById(current.parent) : null;
  }
  
  return ancestors;
};

// Get all descendants
categorySchema.methods.getDescendants = async function() {
  const regex = new RegExp(`^${this.path}/`);
  return await this.constructor.find({ path: regex });
};

// Check if has children
categorySchema.methods.hasChildren = async function() {
  const count = await this.constructor.countDocuments({ parent: this._id });
  return count > 0;
};
```

**STATIC METHODS:**
```javascript
// Get root categories
categorySchema.statics.getRootCategories = function() {
  return this.find({ parent: null, isActive: true, showInMenu: true })
    .sort('displayOrder')
    .populate('children');
};

// Get full tree
categorySchema.statics.getCategoryTree = async function() {
  const categories = await this.find({ isActive: true })
    .sort('displayOrder')
    .lean();
  
  const buildTree = (parentId = null) => {
    return categories
      .filter(cat => String(cat.parent || null) === String(parentId))
      .map(cat => ({
        ...cat,
        children: buildTree(cat._id)
      }));
  };
  
  return buildTree(null);
};
```

---

## 🔄 2. MIGRATION STRATEGY

### 2.1 Migration Script
**File:** `scripts/migrate-categories.js`

**STEP 1: Add missing fields to existing categories**
```javascript
const slugify = require('slugify');

async function migrateExistingCategories() {
  const categories = await Category.find({});
  
  for (const cat of categories) {
    if (!cat.slug) {
      cat.slug = slugify(cat.name, { lower: true, strict: true });
    }
    
    if (cat.level === undefined) {
      cat.level = 0;
      cat.path = cat._id.toString();
    }
    
    if (cat.displayOrder === undefined) {
      cat.displayOrder = 0;
    }
    
    if (cat.isActive === undefined) {
      cat.isActive = true;
    }
    
    if (cat.showInMenu === undefined) {
      // Keep these in menu
      const menuCategories = ['Makeup', 'Skincare', 'Hair', 'Bath & Body', 'Tools & Brushes'];
      cat.showInMenu = menuCategories.includes(cat.name);
    }
    
    await cat.save({ validateBeforeSave: false });
  }
  
  console.log(`✅ Migrated ${categories.length} categories`);
}
```

**STEP 2: Create subcategories**
```javascript
const SUBCATEGORIES = {
  'Makeup': [
    { name: 'Face', subcats: ['Foundation', 'Concealer', 'Powder', 'Blush'] },
    { name: 'Lips', subcats: ['Lipstick', 'Lip Gloss', 'Lip Balm'] },
    { name: 'Eyes', subcats: ['Eyeshadow', 'Mascara', 'Eyeliner'] }
  ],
  'Skincare': [
    { name: 'Cleansers', subcats: ['Foam Cleanser', 'Gel Cleanser', 'Oil Cleanser'] },
    { name: 'Moisturizers', subcats: ['Day Cream', 'Night Cream', 'Serum'] },
    { name: 'Sunscreen', subcats: ['Face Sunscreen', 'Body Sunscreen'] }
  ],
  'Hair': [
    { name: 'Shampoo', subcats: [] },
    { name: 'Conditioner', subcats: [] },
    { name: 'Styling', subcats: ['Hair Spray', 'Hair Gel', 'Hair Oil'] }
  ]
};

async function createSubcategories() {
  for (const [parentName, groups] of Object.entries(SUBCATEGORIES)) {
    const parent = await Category.findOne({ name: parentName });
    if (!parent) continue;
    
    for (let i = 0; i < groups.length; i++) {
      const { name, subcats } = groups[i];
      
      // Create level 1 subcategory
      const subcat = await Category.create({
        name,
        slug: slugify(name, { lower: true, strict: true }),
        parent: parent._id,
        level: 1,
        displayOrder: i,
        isActive: true,
        showInMenu: true
      });
      
      // Create level 2 subcategories
      for (let j = 0; j < subcats.length; j++) {
        await Category.create({
          name: subcats[j],
          slug: slugify(subcats[j], { lower: true, strict: true }),
          parent: subcat._id,
          level: 2,
          displayOrder: j,
          isActive: true,
          showInMenu: true
        });
      }
    }
  }
  
  console.log('✅ Created subcategories');
}
```

**STEP 3: Update product counts**
```javascript
async function updateProductCounts() {
  const categories = await Category.find({});
  
  for (const cat of categories) {
    const count = await Product.countDocuments({ category: cat._id });
    cat.productCount = count;
    await cat.save({ validateBeforeSave: false });
  }
  
  console.log('✅ Updated product counts');
}
```

**COMPLETE MIGRATION SCRIPT:**
```javascript
// Run: node scripts/migrate-categories.js

require('dotenv').config();
const mongoose = require('mongoose');
const Category = require('../models/category.models');
const Product = require('../models/product.models');

async function runMigration() {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('🔗 Connected to MongoDB');
    
    await migrateExistingCategories();
    await createSubcategories();
    await updateProductCounts();
    
    console.log('✅ Migration completed successfully!');
    process.exit(0);
  } catch (error) {
    console.error('❌ Migration failed:', error);
    process.exit(1);
  }
}

runMigration();
```

---

## 🎮 3. CONTROLLER UPDATES

### 3.1 New Category Controller Methods
**File:** `controllers/categoryController.js`

**GET CATEGORY TREE (for navbar):**
```javascript
const getCategoryTree = async (req, res) => {
  try {
    const tree = await Category.getCategoryTree();
    
    res.status(200).json({
      success: true,
      categories: tree
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

**GET ROOT CATEGORIES WITH CHILDREN:**
```javascript
const getRootCategoriesWithChildren = async (req, res) => {
  try {
    const roots = await Category.find({ 
      parent: null, 
      isActive: true,
      showInMenu: true 
    })
    .sort('displayOrder')
    .lean();
    
    // Populate children recursively
    const populateChildren = async (categoryId) => {
      const children = await Category.find({ 
        parent: categoryId,
        isActive: true 
      })
      .sort('displayOrder')
      .lean();
      
      for (const child of children) {
        child.children = await populateChildren(child._id);
      }
      
      return children;
    };
    
    for (const root of roots) {
      root.children = await populateChildren(root._id);
    }
    
    res.status(200).json({
      success: true,
      categories: roots
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

**GET CATEGORY WITH BREADCRUMB:**
```javascript
const getCategoryWithBreadcrumb = async (req, res) => {
  try {
    const { slug } = req.params;
    
    const category = await Category.findOne({ slug })
      .populate('children');
    
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found'
      });
    }
    
    const breadcrumb = await category.getAncestors();
    breadcrumb.push(category);
    
    res.status(200).json({
      success: true,
      category,
      breadcrumb
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

**CREATE SUBCATEGORY:**
```javascript
const createSubcategory = async (req, res) => {
  try {
    const { name, parentId, displayOrder = 0, icon, image } = req.body;
    
    if (!name || !parentId) {
      return res.status(400).json({
        success: false,
        message: 'Name and parentId are required'
      });
    }
    
    const parent = await Category.findById(parentId);
    if (!parent) {
      return res.status(404).json({
        success: false,
        message: 'Parent category not found'
      });
    }
    
    if (parent.level >= 2) {
      return res.status(400).json({
        success: false,
        message: 'Maximum nesting level (3) reached'
      });
    }
    
    const slug = slugify(name, { lower: true, strict: true });
    
    const category = await Category.create({
      name,
      slug,
      parent: parentId,
      level: parent.level + 1,
      displayOrder,
      icon,
      image,
      isActive: true,
      showInMenu: true
    });
    
    res.status(201).json({
      success: true,
      message: 'Subcategory created successfully',
      category
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

**UPDATE CATEGORY HIERARCHY:**
```javascript
const updateCategoryHierarchy = async (req, res) => {
  try {
    const { id } = req.params;
    const { parentId, displayOrder } = req.body;
    
    const category = await Category.findById(id);
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found'
      });
    }
    
    // Check if has products
    if (parentId && category.productCount > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot change parent of category with products'
      });
    }
    
    // Check circular reference
    if (parentId) {
      const parent = await Category.findById(parentId);
      if (!parent) {
        return res.status(404).json({
          success: false,
          message: 'Parent category not found'
        });
      }
      
      const descendants = await category.getDescendants();
      if (descendants.some(d => d._id.toString() === parentId)) {
        return res.status(400).json({
          success: false,
          message: 'Cannot set descendant as parent (circular reference)'
        });
      }
    }
    
    category.parent = parentId || null;
    if (displayOrder !== undefined) {
      category.displayOrder = displayOrder;
    }
    
    await category.save();
    
    res.status(200).json({
      success: true,
      message: 'Category hierarchy updated',
      category
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

**DELETE CATEGORY (with children check):**
```javascript
const deleteCategory = async (req, res) => {
  try {
    const { id } = req.params;
    
    const category = await Category.findById(id);
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found'
      });
    }
    
    // Check if has children
    const hasChildren = await category.hasChildren();
    if (hasChildren) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete category with subcategories. Delete children first.'
      });
    }
    
    // Check if has products
    if (category.productCount > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete category with products. Move or delete products first.'
      });
    }
    
    await category.remove();
    
    res.status(200).json({
      success: true,
      message: 'Category deleted successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

---

## 🛣️ 4. ROUTE UPDATES

### 4.1 New Routes
**File:** `routes/category.routes.js`

```javascript
const router = require('express').Router();
const categoryController = require('../controllers/categoryController');
const { protect, authorize } = require('../middleware/auth');

// Public routes
router.get('/tree', categoryController.getCategoryTree);
router.get('/root-with-children', categoryController.getRootCategoriesWithChildren);
router.get('/:slug/breadcrumb', categoryController.getCategoryWithBreadcrumb);
router.get('/:slug', categoryController.getCategoryBySlug);
router.get('/', categoryController.getAllCategories);

// Admin routes
router.post('/', protect, authorize('admin'), categoryController.createCategory);
router.post('/subcategory', protect, authorize('admin'), categoryController.createSubcategory);
router.put('/:id', protect, authorize('admin'), categoryController.updateCategory);
router.put('/:id/hierarchy', protect, authorize('admin'), categoryController.updateCategoryHierarchy);
router.delete('/:id', protect, authorize('admin'), categoryController.deleteCategory);

module.exports = router;
```

---

## 🎨 5. FRONTEND (Vue3) IMPLEMENTATION

### 5.1 Navbar Component with Mega Menu
**File:** `components/Navbar/CategoryMegaMenu.vue`

```vue
<template>
  <nav class="category-navbar">
    <div 
      v-for="category in rootCategories" 
      :key="category._id"
      class="nav-item"
      @mouseenter="showMegaMenu(category._id)"
      @mouseleave="hideMegaMenu"
    >
      <router-link 
        :to="`/category/${category.slug}`"
        class="nav-link"
      >
        <i v-if="category.icon" :class="category.icon"></i>
        {{ category.name }}
      </router-link>
      
      <!-- Mega Menu Dropdown -->
      <div 
        v-if="activeMenu === category._id && category.children?.length"
        class="mega-menu"
      >
        <div 
          v-for="subcat in category.children" 
          :key="subcat._id"
          class="mega-menu-column"
        >
          <h4 class="mega-menu-title">
            <router-link :to="`/category/${subcat.slug}`">
              {{ subcat.name }}
            </router-link>
          </h4>
          
          <ul v-if="subcat.children?.length" class="mega-menu-list">
            <li v-for="item in subcat.children" :key="item._id">
              <router-link :to="`/category/${item.slug}`">
                {{ item.name }}
              </router-link>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </nav>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import axios from 'axios';

const rootCategories = ref([]);
const activeMenu = ref(null);

const fetchCategories = async () => {
  try {
    const { data } = await axios.get('/api/v1/categories/root-with-children');
    rootCategories.value = data.categories;
  } catch (error) {
    console.error('Failed to fetch categories:', error);
  }
};

const showMegaMenu = (categoryId) => {
  activeMenu.value = categoryId;
};

const hideMegaMenu = () => {
  activeMenu.value = null;
};

onMounted(() => {
  fetchCategories();
});
</script>

<style scoped>
.category-navbar {
  display: flex;
  gap: 2rem;
  padding: 1rem 2rem;
  background: #fff;
  border-bottom: 1px solid #e5e7eb;
}

.nav-item {
  position: relative;
}

.nav-link {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  color: #374151;
  text-decoration: none;
  font-weight: 500;
  transition: color 0.2s;
}

.nav-link:hover {
  color: #ec4899;
}

.mega-menu {
  position: absolute;
  top: 100%;
  left: 0;
  display: flex;
  gap: 3rem;
  min-width: 600px;
  padding: 2rem;
  background: #fff;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
  border-radius: 0.5rem;
  z-index: 1000;
}

.mega-menu-column {
  flex: 1;
}

.mega-menu-title {
  margin-bottom: 1rem;
  font-size: 1rem;
  font-weight: 600;
  color: #111827;
}

.mega-menu-title a {
  color: inherit;
  text-decoration: none;
}

.mega-menu-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.mega-menu-list li {
  margin-bottom: 0.5rem;
}

.mega-menu-list a {
  color: #6b7280;
  text-decoration: none;
  font-size: 0.875rem;
  transition: color 0.2s;
}

.mega-menu-list a:hover {
  color: #ec4899;
}
</style>
```

### 5.2 Breadcrumb Component
**File:** `components/Category/Breadcrumb.vue`

```vue
<template>
  <nav class="breadcrumb" aria-label="Breadcrumb">
    <ol>
      <li>
        <router-link to="/">Home</router-link>
      </li>
      <li v-for="(item, index) in breadcrumb" :key="item._id">
        <span class="separator">/</span>
        <router-link 
          v-if="index < breadcrumb.length - 1"
          :to="`/category/${item.slug}`"
        >
          {{ item.name }}
        </router-link>
        <span v-else class="current">{{ item.name }}</span>
      </li>
    </ol>
  </nav>
</template>

<script setup>
defineProps({
  breadcrumb: {
    type: Array,
    required: true
  }
});
</script>

<style scoped>
.breadcrumb ol {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  list-style: none;
  padding: 0;
  margin: 1rem 0;
  font-size: 0.875rem;
}

.breadcrumb a {
  color: #6b7280;
  text-decoration: none;
}

.breadcrumb a:hover {
  color: #ec4899;
}

.separator {
  color: #d1d5db;
}

.current {
  color: #111827;
  font-weight: 500;
}
</style>
```

---

## 📝 6. PRODUCT CONTROLLER UPDATES

### 6.1 Filter by Category (including subcategories)

**Update `getProductsWithFilters` method:**
```javascript
const getProductsWithFilters = async (req, res) => {
  try {
    const { categorySlug, ...otherFilters } = req.query;
    
    let categoryFilter = {};
    
    if (categorySlug) {
      const category = await Category.findOne({ slug: categorySlug });
      
      if (category) {
        // Get all descendants
        const descendants = await category.getDescendants();
        const categoryIds = [category._id, ...descendants.map(d => d._id)];
        
        categoryFilter = { category: { $in: categoryIds } };
      }
    }
    
    const products = await Product.find({
      ...categoryFilter,
      // ... other filters
    })
    .populate('category', 'name slug')
    .sort(sortOptions)
    .skip(skip)
    .limit(limit);
    
    // ... rest of code
  } catch (error) {
    // ... error handling
  }
};
```

---

## ✅ 7. TESTING CHECKLIST

### Backend Tests:
- [ ] Migration script runs without errors
- [ ] All existing categories have slug, level, path
- [ ] New subcategories created correctly
- [ ] GET /api/v1/categories/tree returns nested structure
- [ ] GET /api/v1/categories/:slug/breadcrumb works
- [ ] POST /api/v1/categories/subcategory creates correctly
- [ ] DELETE category with children fails appropriately
- [ ] Product filtering includes subcategory products

### Frontend Tests:
- [ ] Navbar displays all root categories
- [ ] Mega menu shows on hover
- [ ] Mega menu hides on mouse leave
- [ ] Clicking category navigates correctly
- [ ] Breadcrumb displays correct path
- [ ] Mobile responsive design works

---

## 🚀 8. DEPLOYMENT STEPS

1. **Backup Database:**
   ```bash
   mongodump --uri="mongodb://..." --out=backup-before-migration
   ```

2. **Update Code:**
   - Update category.models.js
   - Update categoryController.js
   - Add new routes
   - Update product filters

3. **Run Migration:**
   ```bash
   node scripts/migrate-categories.js
   ```

4. **Verify:**
   - Check DB in MongoDB Compass
   - Test APIs in Postman
   - Test frontend locally

5. **Deploy:**
   - Push to production
   - Run migration on prod DB
   - Monitor errors

---

## 📌 SUMMARY OF CHANGES

### Models Updated:
- ✅ category.models.js (NEW FIELDS: slug, parent, level, path, displayOrder, etc.)

### Controllers Updated:
- ✅ categoryController.js (NEW METHODS: tree, breadcrumb, subcategory CRUD)
- ✅ productController.js (UPDATE: category filtering logic)

### Routes Added:
- ✅ GET /categories/tree
- ✅ GET /categories/root-with-children
- ✅ GET /categories/:slug/breadcrumb
- ✅ POST /categories/subcategory
- ✅ PUT /categories/:id/hierarchy

### Frontend Components:
- ✅ CategoryMegaMenu.vue (NEW)
- ✅ Breadcrumb.vue (NEW)

### Scripts:
- ✅ migrate-categories.js (NEW)

---

## 🔄 NEXT PHASE: PRODUCT VARIANTS

After Category Hierarchy is complete, proceed to Product Variants implementation (separate document).

---

**END OF CATEGORY HIERARCHY DOCUMENTATION**